#!/usr/bin/python3
"""Hyprland workspace group overlay.

Runs as a persistent daemon. Shows a visual overlay of all windows organized
by workspace group (groups of 10 workspaces sharing a network namespace).
Only groups with 1+ windows are shown. The active window is highlighted.

Modifier release detection uses evdev directly (bypasses compositor key
tracking issues with changegroupactive).

Signals:
  SIGUSR2 — show overlay
  SIGTERM — exit daemon
"""

from ctypes import CDLL

CDLL("libgtk4-layer-shell.so")

import fcntl
import json
import os
import pathlib
import signal
import socket
import struct
import subprocess

import gi

gi.require_version("Gdk", "4.0")
gi.require_version("Gio", "2.0")
gi.require_version("GioUnix", "2.0")
gi.require_version("Graphene", "1.0")
gi.require_version("Gtk", "4.0")
gi.require_version("Gtk4LayerShell", "1.0")

from gi.repository import Gdk, GLib, Gio, GioUnix, Graphene, Gtk, Pango
from gi.repository import Gtk4LayerShell as LayerShell

THUMB_DIR = pathlib.Path(
    os.environ.get("XDG_RUNTIME_DIR", f"/run/user/{os.getuid()}")
) / "hyprflow-thumbs"

EV_KEY = 0x01
EVENT_SIZE = 24
MODIFIER_KEYS = {56, 100, 125, 126}  # L_ALT, R_ALT, L_META, R_META
EVIOCGKEY = 0x80604518
EVIOCGBIT = lambda ev_type, size: 0x80004520 | (size << 16) | ev_type


HYPR_SOCK_DIR = os.path.join(
    os.environ.get("XDG_RUNTIME_DIR", f"/run/user/{os.getuid()}"),
    "hypr",
    os.environ.get("HYPRLAND_INSTANCE_SIGNATURE", ""),
)


def hyprctl_json(command):
    """Query Hyprland via the command socket."""
    sock_path = os.path.join(HYPR_SOCK_DIR, ".socket.sock")
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.settimeout(2)
        sock.connect(sock_path)
        sock.sendall(f"j/{command}".encode())
        chunks = []
        while True:
            data = sock.recv(8192)
            if not data:
                break
            chunks.append(data)
        sock.close()
        return json.loads(b"".join(chunks))
    except (OSError, json.JSONDecodeError, ValueError):
        return None


def build_icon_map():
    icon_map = {}
    for app_info in Gio.AppInfo.get_all():
        if not isinstance(app_info, GioUnix.DesktopAppInfo):
            continue
        wm_class = app_info.get_startup_wm_class()
        icon = app_info.get_icon()
        if not icon:
            continue
        icon_name = icon.to_string()
        if wm_class:
            icon_map[wm_class.lower()] = icon_name
        desktop_id = app_info.get_id() or ""
        if desktop_id.endswith(".desktop"):
            icon_map[desktop_id[:-8].lower()] = icon_name
    return icon_map


def get_workspace_group_windows():
    workspace = hyprctl_json("activeworkspace")
    if not workspace:
        return None, None, None, {}

    ws_id = workspace.get("id", 1)
    active_group_id = (ws_id - 1) // 10 + 1

    clients = hyprctl_json("clients") or []

    active_address = None
    groups = {}
    for client in clients:
        cws_id = client.get("workspace", {}).get("id", 0)
        if cws_id <= 0:
            continue
        if cws_id == ws_id and client.get("focusHistoryID") == 0:
            active_address = client.get("address")
        group_id = (cws_id - 1) // 10 + 1
        groups.setdefault(group_id, []).append(client)

    if active_group_id not in groups:
        groups[active_group_id] = []

    for group_id in groups:
        groups[group_id].sort(
            key=lambda c: (c.get("workspace", {}).get("id", 0), c.get("title", ""))
        )

    return active_address, active_group_id, ws_id, groups


def load_css():
    home = os.path.expanduser("~")
    walker_theme = os.path.join(home, ".config/omarchy/current/theme/walker.css")

    css_paths = [
        "/usr/share/hyprflow/style.css",
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "style.css"),
    ]

    css_file = None
    for path in css_paths:
        if os.path.exists(path):
            css_file = path
            break

    if not css_file:
        return

    theme_css = ""
    if os.path.exists(walker_theme):
        with open(walker_theme) as f:
            theme_css = f.read()

    with open(css_file) as f:
        css_text = f.read()

    combined = theme_css + "\n" + css_text

    provider = Gtk.CssProvider()
    provider.load_from_string(combined)

    display = Gdk.Display.get_default()
    Gtk.StyleContext.add_provider_for_display(
        display, provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
    )


def connect_event_socket():
    sock_path = os.path.join(HYPR_SOCK_DIR, ".socket2.sock")

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(sock_path)
    sock.setblocking(False)
    return sock


def find_keyboard_devices():
    """Find input devices that have both META and ALT keys."""
    devices = []
    for entry in sorted(os.listdir("/dev/input")):
        if not entry.startswith("event"):
            continue
        path = f"/dev/input/{entry}"
        try:
            fd = os.open(path, os.O_RDONLY | os.O_NONBLOCK)
            try:
                key_bits = bytearray(96)
                fcntl.ioctl(fd, EVIOCGBIT(EV_KEY, 96), key_bits)
                has_meta = bool(key_bits[125 // 8] & (1 << (125 % 8)))
                has_alt = bool(key_bits[56 // 8] & (1 << (56 % 8)))
                if has_meta and has_alt:
                    devices.append(fd)
                    continue
            except OSError:
                pass
            os.close(fd)
        except (OSError, PermissionError):
            pass
    return devices


def check_modifiers_held(fds):
    """Check if any Super or Alt key is currently held on any device."""
    for fd in fds:
        try:
            buf = bytearray(96)
            fcntl.ioctl(fd, EVIOCGKEY, buf)
            for key in MODIFIER_KEYS:
                if buf[key // 8] & (1 << (key % 8)):
                    return True
        except OSError:
            pass
    return False


class GroupOverlay(Gtk.Application):
    def __init__(self):
        super().__init__(application_id=None)
        self.window = None
        self.icon_map = None
        self.groups_box = None
        self._event_sock = None
        self._event_buf = b""
        self._active = False
        self._kb_fds = []
        self._last_key = None
        self._active_widget = None
        self._icon_cache = {}

    def do_activate(self):
        self.hold()
        load_css()
        self.icon_map = build_icon_map()

        GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGUSR2, self._show)
        GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGTERM, self._quit)

        try:
            self._event_sock = connect_event_socket()
            GLib.io_add_watch(
                self._event_sock.fileno(),
                GLib.IOCondition.IN,
                self._on_ipc_event,
            )
        except Exception:
            pass

        self._kb_fds = find_keyboard_devices()
        for fd in self._kb_fds:
            GLib.io_add_watch(fd, GLib.IOCondition.IN, self._on_key_event)

    def _show(self):
        self._active = True
        self._last_key = None
        active_addr, active_group_id, active_ws_id, groups = get_workspace_group_windows()
        if not groups:
            self._active = False
            if self.window:
                self.window.set_visible(False)
            return True

        self._capture_thumb(active_ws_id)

        if not self.window:
            self._create_window()

        while child := self.groups_box.get_first_child():
            self.groups_box.remove(child)

        self._populate_items(active_addr, active_group_id, groups)
        self._resize_to_content()

        if not self.window.get_visible():
            self.window.present()
        return True

    def _capture_thumb(self, ws_id):
        THUMB_DIR.mkdir(parents=True, exist_ok=True)
        tmp = str(THUMB_DIR / f"ws-{ws_id}.jpg.tmp")
        try:
            proc = Gio.Subprocess.new(
                ["grim", "-t", "jpeg", "-q", "50", "-s", "0.25", tmp],
                Gio.SubprocessFlags.STDERR_SILENCE,
            )
        except GLib.Error:
            return
        proc.wait_async(None, self._on_capture_done, ws_id)

    def _on_capture_done(self, proc, result, ws_id):
        try:
            proc.wait_finish(result)
        except GLib.Error:
            return
        if proc.get_exit_status() != 0:
            return
        tmp = THUMB_DIR / f"ws-{ws_id}.jpg.tmp"
        final = THUMB_DIR / f"ws-{ws_id}.jpg"
        try:
            tmp.rename(final)
        except OSError:
            return
        # Clean up thumbnails from other workspaces in the same group
        group_id = (ws_id - 1) // 10 + 1
        group_start = (group_id - 1) * 10 + 1
        for other_ws in range(group_start, group_start + 10):
            if other_ws != ws_id:
                old = THUMB_DIR / f"ws-{other_ws}.jpg"
                old.unlink(missing_ok=True)
        if self._active:
            self._last_key = None
            self._refresh()

    def _hide(self):
        self._active = False
        if self.window:
            self.window.set_visible(False)
        return True

    def _refresh(self):
        active_addr, active_group_id, active_ws_id, groups = get_workspace_group_windows()
        if not groups:
            return True
        if not self.window:
            return True
        key = (active_addr, active_group_id,
               tuple((g, tuple(w["address"] for w in ws))
                     for g, ws in sorted(groups.items())))
        if key == self._last_key:
            return True
        self._last_key = key
        while child := self.groups_box.get_first_child():
            self.groups_box.remove(child)
        self._populate_items(active_addr, active_group_id, groups)
        self._resize_to_content()
        return True

    def _quit(self):
        if self.window:
            self.window.destroy()
            self.window = None
        for fd in self._kb_fds:
            os.close(fd)
        if self._event_sock:
            self._event_sock.close()
        self.release()
        self.quit()
        return False

    def _on_key_event(self, fd, condition):
        try:
            data = os.read(fd, EVENT_SIZE * 64)
            if not self._active:
                return True
            for i in range(0, len(data), EVENT_SIZE):
                _, _, typ, code, value = struct.unpack("llHHI", data[i : i + EVENT_SIZE])
                if typ == EV_KEY and code in MODIFIER_KEYS and value == 0:
                    if not check_modifiers_held(self._kb_fds):
                        self._hide()
                        return True
        except OSError:
            pass
        return True

    def _on_ipc_event(self, fd, condition):
        try:
            data = self._event_sock.recv(4096)
            if not data:
                return False
            self._event_buf += data
            while b"\n" in self._event_buf:
                line, self._event_buf = self._event_buf.split(b"\n", 1)
                event = line.decode("utf-8", errors="replace")
                if self._active and (
                    event.startswith("activewindow>>")
                    or event.startswith("workspace>>")
                ):
                    self._refresh()
        except BlockingIOError:
            pass
        except Exception:
            return False
        return True

    def _create_window(self):
        self.window = Gtk.ApplicationWindow(application=self)

        LayerShell.init_for_window(self.window)
        LayerShell.set_layer(self.window, LayerShell.Layer.OVERLAY)
        LayerShell.set_exclusive_zone(self.window, -1)
        LayerShell.set_namespace(self.window, "hypr-group-overlay")

        wrapper = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        wrapper.add_css_class("overlay-wrapper")
        self.window.set_child(wrapper)

        self._scrolled = Gtk.ScrolledWindow()
        self._scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)

        # Determine monitor height for max cap
        self._monitor_height = 1080
        display = Gdk.Display.get_default()
        monitors = display.get_monitors()
        if monitors.get_n_items() > 0:
            monitor = monitors.get_item(0)
            self._monitor_height = monitor.get_geometry().height

        wrapper.append(self._scrolled)

        self.groups_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        self._scrolled.set_child(self.groups_box)

    def _resize_to_content(self):
        """Size the scrolled window to fit content, capped at monitor height."""
        _, natural_h, _, _ = self.groups_box.measure(Gtk.Orientation.VERTICAL, -1)
        # Account for wrapper padding (12px top + 12px bottom from CSS)
        total = natural_h + 24
        height = min(total, self._monitor_height)
        self._scrolled.set_size_request(-1, height)
        # Defer scroll until layout is complete
        if self._active_widget:
            GLib.idle_add(self._scroll_to_active)

    def _scroll_to_active(self):
        """Scroll the active row into view."""
        if not self._active_widget or not self._scrolled:
            return False
        success, point = self._active_widget.compute_point(
            self.groups_box, Graphene.Point()
        )
        if not success:
            return False
        adj = self._scrolled.get_vadjustment()
        widget_y = point.y
        widget_h = self._active_widget.get_height()
        page_size = adj.get_page_size()
        current = adj.get_value()
        # Scroll only if the active widget is outside the visible area
        if widget_y < current:
            adj.set_value(widget_y)
        elif widget_y + widget_h > current + page_size:
            adj.set_value(widget_y + widget_h - page_size)
        return False

    def _populate_items(self, active_addr, active_group_id, groups):
        self._active_widget = None
        display = Gdk.Display.get_default()
        icon_theme = Gtk.IconTheme.get_for_display(display)

        for group_id in sorted(groups):
            section = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
            section.add_css_class("group-section")

            header = Gtk.Label(label=f"Group {group_id}")
            header.add_css_class("group-header")
            header.set_xalign(0.5)
            if group_id == active_group_id:
                header.add_css_class("active-group")
            section.append(header)

            if not groups[group_id]:
                item_box = Gtk.Box(
                    orientation=Gtk.Orientation.HORIZONTAL, spacing=10
                )
                item_box.add_css_class("item-box")
                item_box.add_css_class("active")
                label = Gtk.Label(label="No applications")
                label.add_css_class("item-text")
                label.set_hexpand(True)
                label.set_xalign(0)
                item_box.append(label)
                section.append(item_box)
            else:
                # Group windows by workspace ID (already sorted by ws_id)
                ws_groups = {}
                for win in groups[group_id]:
                    wid = win.get("workspace", {}).get("id", 0)
                    ws_groups.setdefault(wid, []).append(win)

                # Find which workspace has a thumbnail (at most one per group)
                thumb_ws_id = None
                thumb_path = None
                group_start = (group_id - 1) * 10 + 1
                for wid in range(group_start, group_start + 10):
                    p = THUMB_DIR / f"ws-{wid}.jpg"
                    if p.exists():
                        thumb_ws_id = wid
                        thumb_path = p
                        break

                for wid in sorted(ws_groups):
                    is_thumb_ws = thumb_path and wid == thumb_ws_id
                    ws_wins = ws_groups[wid]

                    if is_thumb_ws:
                        grid = Gtk.Grid()
                        grid.set_column_spacing(10)
                        grid.set_row_spacing(0)
                        grid.add_css_class("item-box")
                        grid.add_css_class("thumb-row")

                        has_active = any(
                            w["address"] == active_addr for w in ws_wins
                        )
                        if has_active:
                            grid.add_css_class("active")
                            self._active_widget = grid
                        else:
                            grid.add_css_class("last-active-ws")

                        for row_idx, win in enumerate(ws_wins):
                            image = Gtk.Image()
                            image.add_css_class("item-image")
                            image.set_from_icon_name(
                                self._get_icon_name(win["class"], icon_theme)
                            )
                            image.set_valign(Gtk.Align.CENTER)
                            grid.attach(image, 0, row_idx, 1, 1)

                            raw_title = win.get("title", "")
                            if len(raw_title) > 80:
                                raw_title = raw_title[:80] + "..."
                            title = Gtk.Label(label=raw_title)
                            title.add_css_class("item-text")
                            title.set_wrap(True)
                            title.set_wrap_mode(Pango.WrapMode.WORD_CHAR)
                            title.set_hexpand(True)
                            title.set_size_request(300, -1)
                            title.set_xalign(0)
                            title.set_valign(Gtk.Align.CENTER)
                            grid.attach(title, 1, row_idx, 1, 1)

                            ws_num = win.get("workspace", {}).get("id", 0)
                            slot = ws_num - (group_id - 1) * 10
                            number = Gtk.Label(label=str(slot))
                            number.add_css_class("item-number")
                            number.set_valign(Gtk.Align.CENTER)
                            grid.attach(number, 3, row_idx, 1, 1)

                        try:
                            texture = Gdk.Texture.new_from_filename(
                                str(thumb_path)
                            )
                            picture = Gtk.Picture.new_for_paintable(texture)
                            picture.set_content_fit(Gtk.ContentFit.CONTAIN)
                            picture.set_can_shrink(True)
                            picture.set_size_request(-1, 120)
                            picture.set_hexpand(False)
                            picture.set_vexpand(False)
                            picture.set_valign(Gtk.Align.CENTER)
                            picture.add_css_class("ws-thumbnail")
                            grid.attach(picture, 2, 0, 1, len(ws_wins))
                        except GLib.Error:
                            pass

                        section.append(grid)
                    else:
                        for win in ws_wins:
                            item_box = self._make_window_row(
                                win, active_addr, group_id, icon_theme
                            )
                            section.append(item_box)

            self.groups_box.append(section)

    def _make_window_row(self, win, active_addr, group_id, icon_theme):
        item_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        item_box.add_css_class("item-box")

        if win["address"] == active_addr:
            item_box.add_css_class("active")
            self._active_widget = item_box

        image = Gtk.Image()
        image.add_css_class("item-image")
        image.set_from_icon_name(self._get_icon_name(win["class"], icon_theme))
        item_box.append(image)

        raw_title = win.get("title", "")
        if len(raw_title) > 80:
            raw_title = raw_title[:80] + "..."
        title = Gtk.Label(label=raw_title)
        title.add_css_class("item-text")
        title.set_ellipsize(Pango.EllipsizeMode.NONE)
        title.set_hexpand(True)
        title.set_xalign(0)
        item_box.append(title)

        ws_id = win.get("workspace", {}).get("id", 0)
        slot = ws_id - (group_id - 1) * 10
        number = Gtk.Label(label=str(slot))
        number.add_css_class("item-number")
        item_box.append(number)

        return item_box

    def _resolve_icon(self, app_class):
        if not app_class or not self.icon_map:
            return None
        lower = app_class.lower()
        if lower in self.icon_map:
            return self.icon_map[lower]
        for key, val in self.icon_map.items():
            if key in lower or lower in key:
                return val
        return None

    def _get_icon_name(self, app_class, icon_theme):
        if app_class in self._icon_cache:
            return self._icon_cache[app_class]
        icon_name = self._resolve_icon(app_class)
        if icon_name and icon_theme.has_icon(icon_name):
            result = icon_name
        else:
            result = "application-x-executable"
        self._icon_cache[app_class] = result
        return result


PID_FILE = os.path.join(
    os.environ.get("XDG_RUNTIME_DIR", f"/run/user/{os.getuid()}"),
    "hypr-group-overlay.pid",
)

CONFIG_FILES = [
    "/etc/hypr-devns.conf",
    os.path.expanduser("~/.config/hypr-devns.conf"),
]


def is_enabled():
    value = "true"
    for path in CONFIG_FILES:
        try:
            with open(path) as f:
                for line in f:
                    if line.strip().startswith("GROUP_OVERLAY="):
                        value = line.strip().split("=", 1)[1].strip('"').strip("'")
        except FileNotFoundError:
            pass
    return value != "false"


def main():
    if not is_enabled():
        return

    try:
        with open(PID_FILE) as f:
            old_pid = int(f.read().strip())
        if old_pid != os.getpid():
            os.kill(old_pid, signal.SIGTERM)
    except (FileNotFoundError, ValueError, ProcessLookupError, PermissionError):
        pass

    # Atomic write: temp file + rename prevents TOCTOU race
    tmp = PID_FILE + ".tmp"
    with open(tmp, "w") as f:
        f.write(str(os.getpid()))
    os.rename(tmp, PID_FILE)

    app = GroupOverlay()
    app.run(None)


if __name__ == "__main__":
    main()
